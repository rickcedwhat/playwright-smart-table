/**
 * ðŸ¤– AUTO-GENERATED FILE. DO NOT EDIT.
 * This file is generated by scripts/embed-types.js
 * It contains the raw text of types.ts to provide context for LLM prompts.
 */
export const TYPE_CONTEXT = `
export type Selector = string | ((root: Locator | Page) => Locator);

/**
 * Function to get a cell locator given row, column info.
 * Replaces the old cellResolver.
 */
export type GetCellLocatorFn = (args: {
  row: Locator;
  columnName: string;
  columnIndex: number;
  rowIndex?: number;
  page: Page;
}) => Locator;

/**
 * Function to get the currently active/focused cell.
 * Returns null if no cell is active.
 */
export type GetActiveCellFn = (args: TableContext) => Promise<{
  rowIndex: number;
  columnIndex: number;
  columnName?: string;
  locator: Locator;
} | null>;


export type SmartRow<T = any> = Locator & {
  getRequestIndex(): number | undefined;
  rowIndex?: number;
  getCell(column: string): Locator;
  toJSON(options?: { columns?: string[] }): Promise<T>;
  /**
   * Scrolls/paginates to bring this row into view.
   * Only works if rowIndex is known.
   */
  bringIntoView(): Promise<void>;
  /**
   * Fills the row with data. Automatically detects input types.
   */
  fill: (data: Partial<T> | Record<string, any>, options?: FillOptions) => Promise<void>;
  /**
   * Alias for fill() to avoid conflict with Locator.fill()
   */
  smartFill: (data: Partial<T> | Record<string, any>, options?: FillOptions) => Promise<void>;
};

export type StrategyContext = TableContext & { rowLocator?: Locator; rowIndex?: number };

/**
 * Defines the contract for a sorting strategy.
 */
export interface SortingStrategy {
  /**
   * Performs the sort action on a column.
   */
  doSort(options: {
    columnName: string;
    direction: 'asc' | 'desc';
    context: StrategyContext;
  }): Promise<void>;

  /**
   * Retrieves the current sort state of a column.
   */
  getSortState(options: {
    columnName: string;
    context: StrategyContext;
  }): Promise<'asc' | 'desc' | 'none'>;
}

export interface TableContext {
  root: Locator;
  config: FinalTableConfig;
  page: Page;
  resolve: (selector: Selector, parent: Locator | Page) => Locator;
}

export type PaginationStrategy = (context: TableContext) => Promise<boolean>;

export type DedupeStrategy = (row: SmartRow) => string | number | Promise<string | number>;

export interface PromptOptions {
  /**
   * Output Strategy:
   * - 'error': Throws an error with the prompt (useful for platforms that capture error output cleanly).
   * - 'console': Standard console logs (Default).
   */
  output?: 'console' | 'error';
  includeTypes?: boolean;
}

export type FillStrategy = (options: {
  row: SmartRow;
  columnName: string;
  value: any;
  index: number;
  page: Page;
  rootLocator: Locator;
  table: TableResult; // The parent table instance
  fillOptions?: FillOptions;
}) => Promise<void>;

export type { HeaderStrategy } from './strategies/headers';
export type { CellNavigationStrategy } from './strategies/columns';

/**
 * Strategy to resolve column names (string or regex) to their index.
 */
export type { ColumnResolutionStrategy } from './strategies/resolution';

/**
 * Strategy to filter rows based on criteria.
 */
export interface FilterStrategy {
  apply(options: {
    rows: Locator;
    filter: { column: string, value: string | RegExp | number };
    colIndex: number;
    tableContext: TableContext;
  }): Locator;
}

/**
 * Organized container for all table interaction strategies.
 */
export interface TableStrategies {
  /** Strategy for discovering/scanning headers */
  header?: HeaderStrategy;
  /** Strategy for navigating to specific cells (row + column) */
  cellNavigation?: CellNavigationStrategy;
  /** Strategy for filling form inputs */
  fill?: FillStrategy;
  /** Strategy for paginating through data */
  pagination?: PaginationStrategy;
  /** Strategy for sorting columns */
  sorting?: SortingStrategy;
  /** Function to get a cell locator */
  getCellLocator?: GetCellLocatorFn;
  /** Function to get the currently active/focused cell */
  getActiveCell?: GetActiveCellFn;
}

/**
 * Configuration options for useTable.
 */
export interface TableConfig {
  /** Selector for the table headers */
  headerSelector?: string;
  /** Selector for the table rows */
  rowSelector?: string;
  /** Selector for the cells within a row */
  cellSelector?: string;
  /** Number of pages to scan for verification */
  maxPages?: number;
  /** Hook to rename columns dynamically */
  headerTransformer?: (args: { text: string, index: number, locator: Locator }) => string | Promise<string>;
  /** Automatically scroll to table on init */
  autoScroll?: boolean;
  /** Enable debug logs */
  debug?: boolean;
  /** Reset hook */
  onReset?: (context: TableContext) => Promise<void>;
  /** All interaction strategies */
  strategies?: TableStrategies;
}

export interface FinalTableConfig extends TableConfig {
  headerSelector: string;
  rowSelector: string;
  cellSelector: string;
  maxPages: number;
  autoScroll: boolean;
  debug: boolean;
  headerTransformer: (args: { text: string, index: number, locator: Locator }) => string | Promise<string>;
  onReset: (context: TableContext) => Promise<void>;
  strategies: TableStrategies;
}


export interface FillOptions {
  /**
   * Custom input mappers for specific columns.
   * Maps column names to functions that return the input locator for that cell.
   */
  inputMappers?: Record<string, (cell: Locator) => Locator>;
}

export interface TableResult<T = any> {
  /**
   * Initializes the table by resolving headers. Must be called before using sync methods.
   * @param options Optional timeout for header resolution (default: 3000ms)
   */
  init(options?: { timeout?: number }): Promise<TableResult>;

  getHeaders: () => Promise<string[]>;
  getHeaderCell: (columnName: string) => Promise<Locator>;

  /**
   * Finds a row by filters on the current page only. Returns immediately (sync).
   * Throws error if table is not initialized.
   */
  getByRow: (
    filters: Record<string, string | RegExp | number>,
    options?: { exact?: boolean }
  ) => SmartRow;

  /**
   * Gets a row by 1-based index on the current page.
   * Throws error if table is not initialized.
   * @param index 1-based row index
   * @param options Optional settings including bringIntoView
   */
  getByRowIndex: (
    index: number,
    options?: { bringIntoView?: boolean }
  ) => SmartRow;

  /**
   * Searches for a row across all available data using the configured strategy (pagination, scroll, etc.).
   * Auto-initializes if needed.
   */
  searchForRow: (
    filters: Record<string, string | RegExp | number>,
    options?: { exact?: boolean, maxPages?: number }
  ) => Promise<SmartRow>;

  /**
   * Navigates to a specific column using the configured CellNavigationStrategy.
   */
  scrollToColumn: (columnName: string) => Promise<void>;

  getAllCurrentRows: <T extends { asJSON?: boolean }>(
    options?: { filter?: Record<string, any>, exact?: boolean } & T
  ) => Promise<T['asJSON'] extends true ? Record<string, string>[] : SmartRow[]>;

  /**
   * @deprecated Use getAllCurrentRows instead. This method will be removed in a future major version.
   */
  getAllRows: <T extends { asJSON?: boolean }>(
    options?: { filter?: Record<string, any>, exact?: boolean } & T
  ) => Promise<T['asJSON'] extends true ? Record<string, string>[] : SmartRow[]>;

  generateConfigPrompt: (options?: PromptOptions) => Promise<void>;
  generateStrategyPrompt: (options?: PromptOptions) => Promise<void>;

  /**
   * Resets the table state (clears cache, flags) and invokes the onReset strategy.
   */
  reset: () => Promise<void>;

  /**
   * Revalidates the table's structure (headers, columns) without resetting pagination or state.
   * Useful when columns change visibility or order dynamically.
   */
  revalidate: () => Promise<void>;

  /**
   * Scans a specific column across all pages and returns the values.
   */
  getColumnValues: <V = string>(column: string, options?: { mapper?: (cell: Locator) => Promise<V> | V, maxPages?: number }) => Promise<V[]>;

  /**
   * Provides access to sorting actions and assertions.
   */
  sorting: {
    /**
     * Applies the configured sorting strategy to the specified column.
     * @param columnName The name of the column to sort.
     * @param direction The direction to sort ('asc' or 'desc').
     */
    apply(columnName: string, direction: 'asc' | 'desc'): Promise<void>;
    /**
     * Gets the current sort state of a column using the configured sorting strategy.
     * @param columnName The name of the column to check.
     * @returns A promise that resolves to 'asc', 'desc', or 'none'.
     */
    getState(columnName: string): Promise<'asc' | 'desc' | 'none'>;
  };

  /**
   * Iterates through paginated table data, calling the callback for each iteration.
   * Callback return values are automatically appended to allData, which is returned.
   */
  iterateThroughTable: <T = any>(
    callback: (context: {
      index: number;
      isFirst: boolean;
      isLast: boolean;
      rows: SmartRow[];
      allData: T[];
      table: RestrictedTableResult;
    }) => T | Promise<T>,
    options?: {
      pagination?: PaginationStrategy;
      dedupeStrategy?: DedupeStrategy;
      maxIterations?: number;
      getIsFirst?: (context: { index: number }) => boolean;
      getIsLast?: (context: { index: number, paginationResult: boolean }) => boolean;
      onFirst?: (context: { index: number, rows: SmartRow[], allData: any[] }) => void | Promise<void>;
      onLast?: (context: { index: number, rows: SmartRow[], allData: any[] }) => void | Promise<void>;
    }
  ) => Promise<T[]>;
}

/**
 * Restricted table result that excludes methods that shouldn't be called during iteration.
 */
export type RestrictedTableResult<T = any> = Omit<TableResult<T>, 'searchForRow' | 'iterateThroughTable' | 'reset' | 'getAllRows'>;
`;
